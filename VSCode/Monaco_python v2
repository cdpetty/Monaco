import random
import math

class Company:
    def __init__(self, name, stage, valuation, state, firm_invested_capital, firm_ownership, stages, valuations, dilution):
        self.name = name
        self.stage = stage
        self.valuation = valuation
        self.state = state
        self.firm_invested_capital = firm_invested_capital
        self.firm_ownership = firm_ownership
        self.market_constraints = {
            'stages': stages,
            'valuations': valuations,
            'dilution': dilution
        }
    
    def promote(self, secondary_dry_powder):
        ## print('Promotion triggered with secondary capital:', secondary_dry_powder)
        self.stage = self.market_constraints['stages'][min(self.market_constraints['stages'].index(self.stage) + 1, len(self.market_constraints['stages'])-1)]
        self.valuation = self.market_constraints['valuations'][self.stage]
        ## print('Promoted to:', self.stage, 'with valuation:', self.valuation, 'and previous ownership of', self.firm_ownership)

        dilution = self.market_constraints['dilution'][self.stage]
        post_dilution_ownership = self.firm_ownership*(1-dilution)
        pro_rata_investment = min((self.firm_ownership - post_dilution_ownership)*self.valuation, secondary_dry_powder)
        ##print('Pro rata investment:', pro_rata_investment, 'on dilution of', dilution)
        
        self.firm_invested_capital += pro_rata_investment
        self.firm_ownership = (self.firm_ownership*(1-dilution)) + pro_rata_investment/self.valuation ## minus dilution + pro rata investment ownership
        ##print('final firm ownership', self.firm_ownership)
        return pro_rata_investment
            

    def m_and_a(self):
        self.state = "Acquired"

        m_and_a_outcome_odds = [0.01, 0.02, 0.27, 0.7]
        m_and_a_multipliers = [10,5,1,.5]

        rand = random.random()
        if rand <m_and_a_outcome_odds[0]:
            # print('10x')
            self.valuation = m_and_a_multipliers[0]*self.valuation
        elif rand < m_and_a_outcome_odds[0]+m_and_a_outcome_odds[1]:
            # print('5x')
            self.valuation = m_and_a_multipliers[1]*self.valuation
        elif rand < m_and_a_outcome_odds[0]+m_and_a_outcome_odds[1]+m_and_a_outcome_odds[2]:
            # print('1x')
            self.valuation = m_and_a_multipliers[2]*self.valuation
        else:
            # print('0.5x')
            self.valuation = m_and_a_multipliers[3]*self.valuation
    
    def get_firm_value(self):
        return self.valuation * self.firm_ownership

    def fail(self):
        self.state = 'Failed'
        self.valuation = 0
    
    def get_numerical_stage(self):
        return self.market_constraints['stages'].index(self.stage)

    def __str__(self):
        return '[' + self.name + ', ' + self.stage + ', ' + str(self.valuation) + ', ' + self.state + ', ' + str(self.firm_invested_capital) + ', ' + str(self.firm_ownership) + ']'
    
    def __repr__(self):
        return '[' + self.name + ', ' + self.stage + ', ' + str(self.valuation) + ', ' + self.state + ', ' +  str(self.firm_ownership) + ',' + str(self.get_firm_value()) + ']\n'


#############################################################################
#############################################################################
############################# FIRM CLASS ####################################
#############################################################################
#############################################################################
class Firm:
    def __init__(self, name, primary_investments, follow_on_reserve, fund_size, firm_lifespan_years):
        self.name = name
        self.primary_investments = primary_investments
        self.follow_on_reserve = follow_on_reserve
        self.primary_capital_deployed = 0
        self.follow_on_capital_deployed = 0
        self.fund_size = fund_size
        self.firm_lifespan_years = firm_lifespan_years
        self.portfolio = []
    
    def initialize_portfolio(self, stages, valuations, dilution, investments):
        for primary_capital_rounds in investments:
            stage_invested = primary_capital_rounds[0]
            capital_invested = primary_capital_rounds[1]

            self.portfolio.append(Company('comp_name' + stage_invested[:2] + str(capital_to_be_allocated), 
                                        stage_invested, 
                                        valuations[stage_invested],
                                        'Alive', 
                                        capital_invested, 
                                        capital_invested/valuations[stage_invested],
                                        stages, 
                                        valuations, 
                                        dilution))
            
                capital_to_be_allocated -= capital_invested
                self.primary_capital_deployed += capital_invested
        # print('----------------------------------------------------------')
        # print('Initialized portfolio with', len(self.portfolio))
        # print('Pre-seed', len(list(filter(lambda x: x.stage == 'Pre-seed', self.portfolio))))
        # print('Seed', len(list(filter(lambda x: x.stage == 'Seed', self.portfolio))))
        # print('----------------------------------------------------------')
    
    def new_portfolio_company(self, stage_invested, capital_invested, stages, valuations, dilution):
        self.primary_capital_deployed += capital_invested
        self.portfolio.append(Company('comp_name' + stage_invested[:2] + 'extra', 
                                stage_invested, 
                                valuations[stage_invested],
                                'Alive', 
                                capital_invested, 
                                capital_invested/valuations[stage_invested],
                                stages, 
                                valuations, 
                                dilution))


    def concise_portfolio_value(self):
        total_value = 0
        for portco in self.portfolio:
            if portco.state == 'Alive':
                total_value += portco.valuation * portco.firm_ownership
            elif portco.state == 'Failed':
                total_value += 0
            elif portco.state == 'Acquired':
                total_value += portco.valuation * portco.firm_ownership
        return total_value

    def detailed_portfolio_value(self):
        total_value = {
            'Alive': 0,
            'Acquired': 0
        }
        for portco in self.portfolio:
            # print(portco.stage, portco.state, '-- val', portco.valuation, 'return', portco.valuation*portco.firm_ownership, 'ic', portco.firm_invested_capital, 'ownership', portco.firm_ownership)
            if portco.state == 'Alive':
                total_value['Alive'] += portco.valuation * portco.firm_ownership
            elif portco.state == 'Acquired':
                total_value['Acquired'] += portco.valuation * portco.firm_ownership
        return total_value

    def get_capital_invested(self):
        return self.primary_capital_deployed + self.follow_on_capital_deployed
    
    def get_remaining_follow_on_capital(self):
        return self.follow_on_reserve - self.follow_on_capital_deployed
    
    def get_irr(self):
        fv = self.concise_portfolio_value()
        pv = self.primary_capital_deployed + self.follow_on_capital_deployed
        # print(fv, pv)
        IRR = ((fv / pv) ** (1/self.firm_lifespan_years)) -1
        return IRR

    def get_MoM(self):
        MoM = round(self.concise_portfolio_value()/self.get_capital_invested(), 1)
        return MoM
    
    def __repr__(self):
        # f = {
        #     'Seed':0,
        #     'Series A':0,
        #     'Series B':0,
        #     'Series C':0,
        #     'Series D':0,
        #     'Series E':0,
        #     'Series F':0,
        #     'Failed': 0,
        #     'Acquired': 0
        # }
        f = {
            'Alive':0,
            'Failed': 0,
            'Acquired': 0
        }
        for comp in self.portfolio:
            if comp.state == 'Alive':
                # f[comp.stage] += 1
                f['Alive'] += 1
            elif comp.state == 'Failed':
                f['Failed'] += 1
            elif comp.state == 'Acquired':
                f['Acquired'] += 1 
        return str(f)


#############################################################################
#############################################################################
###################           MONTECARLO CLASS        #######################
#############################################################################
#############################################################################
class Montecarlo:
    def __init__(self, num_scenarios, stages, stage_probs, stage_valuations, stage_dilution, firm_attributes):
        self.num_scenarios = num_scenarios
        self.firm_scenarios = []
        self.stages = stages
        self.stage_probs = stage_probs
        self.stage_valuations = stage_valuations
        self.stage_dilution = stage_dilution
        self.firm_attributes = firm_attributes
    
    def initialize_scenarios(self):
        # print(self.firm_attributes)
        for i in range(self.num_scenarios):
            new_firm = Firm('Gradient'+ str(i), 
                            self.firm_attributes['primary_investments'], 
                            self.firm_attributes['follow_on_reserve'], 
                            self.firm_attributes['fund_size'], 
                            self.firm_attributes['firm_lifespan_years'])
            new_firm.initialize_portfolio(self.stages, self.stage_valuations, self.stage_dilution)
            self.firm_scenarios.append(new_firm)
            ##print('Scenariosxxxx', self.firm_scenarios)
        
    def simulate(self):
        ## For each scenario
        ## print('Scenarios0000000', self.firm_scenarios)
        for firm in self.firm_scenarios:
            
            ## Iteratively age companies in portfolio, deploying any secondary capital available
            for period in range(self.firm_attributes['firm_lifespan_periods']):
                
                for company in firm.portfolio:
                    
                    if company.state == 'Alive' and company.get_numerical_stage() < len(self.stages)-1:
                        rand = random.random()
                        # print ('Company', rand, self.stage_probs[company.stage][0])
                        if rand < self.stage_probs[company.stage][2]:
                            company.m_and_a()
                        elif rand < self.stage_probs[company.stage][2] + self.stage_probs[company.stage][1]:
                            company.fail()
                        else: 
                            secondary_capital_consumed = company.promote(firm.get_remaining_follow_on_capital())
                            firm.follow_on_capital_deployed += secondary_capital_consumed
                    elif company.state == 'Failed':
                        pass
                    elif company.state == 'Acquired':
                        pass
                ##print('End of Period: ', period)
                ## print(firm, '\n',firm.portfolio)
        ## print('Scenarios1111', self.firm_scenarios)
            ## If there is remaining secondary capital, then deploy it iteratively into incremental companies
            while firm.get_remaining_follow_on_capital() > 0 and firm.get_remaining_follow_on_capital() > self.firm_attributes['primary_investments'][0][1]:
                for stage in self.firm_attributes['primary_investments']:
                    if firm.get_remaining_follow_on_capital() > stage[1]:
                            # def new_portfolio_company(self, stage_invested, capital_invested, stages, valuations, dilution):
# 
                        firm.new_portfolio_company(stage[0], stage[1], self.stages, self.stage_valuations, self.stage_dilution)
                        firm.primary_capital_deployed += stage[1]
                    else:
                        break
                
                

    
    def get_IRR_return_outcomes(self):
        outcomes = []
        for firm in self.firm_scenarios:
            outcomes.append(firm.get_irr())
        return outcomes

    def get_MoM_return_outcomes(self):
        outcomes = []
        # print('Scenariosppppp', self.firm_scenarios)
        for firm in self.firm_scenarios:
            print(firm.get_capital_invested())
            outcomes.append(firm.get_MoM())
        return outcomes
    
    def get_median_return_outcome(self, type):
        outcomes = []
        if type == 'MoM':
            outcomes = self.get_MoM_return_outcomes()
        elif type == 'IRR':
            outcomes = self.get_IRR_return_outcomes()
        if len(outcomes) % 2 == 0:
            return (outcomes[len(outcomes)//2] + outcomes[len(outcomes)//2 - 1])/2
        else:
            return outcomes[len(outcomes)//2]
            
        

    def get_exact_return_outcomes(self):
        outcomes = []
        for firm in self.firm_scenarios:
            outcomes.append(firm.concise_portfolio_value())
        return outcomes



    def print_montecarlo_histogram(self):
        outcomes = self.get_MoM_return_outcomes()
        hist_size = .5
        counter = 0.0
        while counter < max(outcomes)+hist_size:
            relevant = list(filter(lambda y: counter <= y < counter+hist_size, outcomes))
            print(f"{counter}-{counter+hist_size}:" + str(len(relevant)) + f":{len(relevant)/self.num_scenarios:.1%}")
            counter += hist_size
        

        # ## print('OOOOutcomes', outcomes)
        # highest = math.ceil(max(outcomes))
        # hist_size = 1
        # x = 0
        # tuples = []
        # for x in range (0, highest):
        #     relevant = list(filter(lambda y: x <= y < x+hist_size, outcomes))
        #     tuples.append([f"{x}-{x+hist_size}", len(relevant), f"{len(relevant)/self.num_scenarios:.1%}"])
        # return tuples


    
    def get_montecarlo_outcomes_overview(self):
        return {
            'Num Simulations': self.num_scenarios,
            'Fund Size': self.firm_attributes['fund_size'],
            'Initial Investment': self.firm_attributes['primary_investments'],
            'Follow on': self.firm_attributes['follow_on_reserve'],
            'Median MoM': self.get_median_return_outcome('MoM'),
            'Median IRR': f"{self.get_median_return_outcome('IRR'):.1%}"
        }

    def print_results(self):
        print(f"Montecarlo Simulation Results ({self.num_scenarios} scenarios):")
        for i, scenario in enumerate(self.firm_scenarios, start=1):
            print(f"Scenario {i}: {scenario}")
            

def main():
    num_scenarios = 10000
    stages = ['Pre-seed', 'Seed', 'Series A', 'Series B', 'Series C', 'Series D', 'Series E', 'Series F']
    
    #Probability distribution: next round, fail, m&a,
    stage_probs = {
        'Pre-seed': [.61, .24, .16],
        'Seed': [.70, .20, .10],
        'Series A':    [.61, .24, .16],
        'Series C':    [.38, .50, .11],
        'Series B':    [.52, .32, .17],
        'Series D':    [.33, .56, .11],
        'Series E':    [.22, .57, .21],
        'Series F':    [.10, .80, .10] #note this case is not triggered unless there is a Series G
    }

    stage_dilution = {
        'Seed': 0.15,
        'Series A': 0.2,
        'Series B': 0.2,
        'Series C': 0.15,
        'Series D': 0.1,
        'Series E': 0.1,
        'Series F': 0.1
    }

    stage_valuations = {
        'Pre-seed': 12,
        'Seed': 25,
        'Series A': 60,
        'Series B': 300,
        'Series C': 500,
        'Series D': 750,
        'Series E': 1500,
        'Series F': 10000
    }
    
    firm_attributes = {
        'primary_investments': ['Pre-seed', 1, 100]*100], ## round, invested capital, total capital allocated to this stage
        'follow_on_reserve': 500, ## total dollars reserved for fund size
        'fund_size': 600,
        
        'firm_lifespan_periods': 7,
        'firm_lifespan_years': 11
    }
    
    ## Perform checks that firm attributes are properly set
    if firm_attributes['follow_on_reserve'] + sum(investment[-1] for investment in firm_attributes['primary_investments']) != firm_attributes['fund_size']:
        print('Error: Fund size does not match capital allocation')
        return
    if firm_attributes['firm_lifespan_periods'] != len(stages)-1 or len(stages) != len(stage_valuations.keys()) or len(stages) != len(stage_probs.keys()):
        print('Error: Stages do not match probabilities, valuations, or firm lifespan')
        return
    for r in firm_attributes['primary_investments']:
        if r[2] / r[1] != round(r[2] / r[1]) and r[2]* r[1] == r[3]:
            print('Error: Pimary investment capital allocated and amount of capital do not align')
            return
         

    ## print('\nInitializing Montecarlo simulation with structure:', firm_attributes, '\n')
    montecarlo = Montecarlo(num_scenarios, stages, stage_probs, stage_valuations, stage_dilution, firm_attributes)
    montecarlo.initialize_scenarios()
    montecarlo.simulate()
    
    ## print(sorted(montecarlo.get_IRR_return_outcomes()))
    ## print([f"{num*100:.1f}%" for num in sorted(montecarlo.get_IRR_return_outcomes())], '\n')
    ## print(list(map(lambda x : round(x), sorted(montecarlo.get_exact_return_outcomes()))), '\n')
    print('Overview of simulation outputs:', montecarlo.get_montecarlo_outcomes_overview(), '\n')
    montecarlo.print_montecarlo_histogram()










if __name__ == '__main__':
    main()